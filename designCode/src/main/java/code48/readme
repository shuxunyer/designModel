代理模式：代理在RPC、监控、缓存等场景中的应用

结构型模式：
结构性模式主要总结了一些类或对象组合字一起的经典解耦
这些经典解耦可以解决特定应用场景的问题
结构型模式包括：
代理模式、桥接模式
装饰器模式、适配器模式、门面模式、组合模式
享元模式

代理模式：
在不改变原始类(被代理类)代码的情况下，通过引入代理类来给原始类附加功能，

release1:
开发了一个MericsController类用来收集接口请求的原始数据、比如访问时间处理时长
很明显：这种处理方式有两个问题：
1 代码不易维护：性能计数器框架代码跟业务代码耦合，如果未来需要替换这个性能计数器代码，成本较大
2 收集接口请求的代码跟业务代码无关，本就不该放入一个类中，
  业务类本着职责单一原则，只聚焦业务处理

release2:
参照基于接口而非实现编程的设计思想，将原始类替换成代理类对象的时候，为了让代码改动尽量少，
在刚刚的代理模式的代码实现中，代理类和原始类需要实现相同的接口。

但是如果原始类没有定义接口，原始类不是我们开发和维护的(比如说来自一个第三方库)
我们也没办法修改原始类，给它重新定义一个接口，这种情况下该如何实现代理模式

release3:
对于这种外部类的扩展，我们一般采用继承的方式，我们让继承类继承原始类，然后扩展附加功能

缺点：
1 如果需要扩展的类有很多，那么需要为每个原始类添加代理类
2 我们需要在代理类中将原始类中的所有方法都实现一遍

release4:
可以使用动态代理来解决release3中的缺点
动态代理底层依赖的是java的反射语法
